// Generated by CoffeeScript 1.3.3
var fs, utils;

fs = require('fs');

utils = require('./utils');

/*

Reading data from a source
--------------------------

The `from` property provide convenient functions to read some csv input.
*/


module.exports = function(csv) {
  var options;
  options = {
    delimiter: ',',
    quote: '"',
    escape: '"',
    columns: null,
    flags: 'r',
    encoding: 'utf8',
    bufferSize: 8 * 1024 * 1024,
    trim: false,
    ltrim: false,
    rtrim: false
  };
  return {
    /*
    
        `options([options])`: Set or get options
        ----------------------------------------
    
        Options are:
    
        -   `delimiter`     Set the field delimiter, one character only, defaults to comma.
        -   `quote`         Set the field delimiter, one character only, defaults to double quotes.
        -   `escape`        Set the field delimiter, one character only, defaults to double quotes.
        -   `columns`       List of fields or true if autodiscovered in the first CSV line, impact the `transform` argument and the `data` event by providing an object instead of an array, order matters, see the transform and the columns sections below.
        -   `encoding`      Defaults to 'utf8', applied when a readable stream is created.
        -   `trim`          If true, ignore whitespace immediately around the delimiter, defaults to false.
        -   `ltrim`         If true, ignore whitespace immediately following the delimiter (i.e. left-trim all fields), defaults to false.
        -   `rtrim`         If true, ignore whitespace immediately preceding the delimiter (i.e. right-trim all fields), defaults to false.
    */

    options: function() {
      if (arguments.length) {
        utils.merge(options, arguments[0]);
        return csv;
      } else {
        return options;
      }
    },
    /*
    
        `array:(data, [options])`: Read from an array
        ---------------------------------------------
        
        Take an array as first argument and optionally some options 
        as a second argument. Each element of the array represents 
        a csv record. Those elements may be a string, a buffer, an
        array or an object.
    */

    array: function(data, options) {
      this.options(options);
      process.nextTick(function() {
        var i, _i, _ref;
        for (i = _i = 0, _ref = data.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
          csv.write(data[i]);
        }
        return csv.end();
      });
      return csv;
    },
    /*
        
        `string:(data, [options])`: Read from a string or a buffer
        ----------------------------------------------------------
        
        Take a string as first argument and optionally an object 
        of options as a second argument. The string must be the 
        complete csv data and may contains more than one line.
    */

    string: function(data, options) {
      this.options(options);
      process.nextTick(function() {
        csv.write(data);
        return csv.end();
      });
      return csv;
    },
    /*
        
        `path(path, [options])`: Read from a file path
        ----------------------------------------------
        
        Take a file path as first argument and optionally an object 
        of options as a second argument.
    */

    path: function(path, options) {
      var stream;
      this.options(options);
      stream = fs.createReadStream(path, csv.from.options());
      stream.setEncoding(csv.from.options().encoding);
      return csv.from.stream(stream, null);
    },
    /*
        
        `stream(readStream, [options])`: Read from a stream
        ---------------------------------------------------
        
        Take a readable stream as first argument and optionally 
        an object of options as a second argument.
    */

    stream: function(readStream, options) {
      this.options(options);
      readStream.on('data', function(data) {
        return csv.write(data.toString());
      });
      readStream.on('error', function(e) {
        return error(e);
      });
      readStream.on('end', function() {
        return csv.end();
      });
      csv.readStream = readStream;
      return csv;
    }
  };
};
