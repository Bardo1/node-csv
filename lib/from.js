// Generated by CoffeeScript 1.3.3
var fs, utils;

fs = require('fs');

utils = require('./utils');

/*

Reading data from a source
--------------------------

The `from` property provide convenient functions to read some csv input.
*/


module.exports = function(csv) {
  return {
    /*
    
      `from.options([options])`: Set or get options
      ---------------------------------------------
    
      Options are:  
    
      *   `delimiter`   Set the field delimiter, one character only, defaults to comma.
      *   `quote`       Set the field delimiter, one character only, defaults to double quotes.
      *   `escape`      Set the field delimiter, one character only, defaults to double quotes.
      *   `columns`     List of fields or true if autodiscovered in the first CSV line, impact the `transform` argument and the `data` event by providing an object instead of an array, order matters, see the transform and the columns sections below.
      *   `flags`     
      *   `encoding`    Defaults to 'utf8', applied when a readable stream is created.
      *   `bufferSize`  
      *   `trim`        If true, ignore whitespace immediately around the delimiter, defaults to false.
      *   `ltrim`       If true, ignore whitespace immediately following the delimiter (i.e. left-trim all fields), defaults to false.
      *   `rtrim`       If true, ignore whitespace immediately preceding the delimiter (i.e. right-trim all fields), defaults to false.
    */

    options: function(options) {
      if (options != null) {
        utils.merge(csv.options.from, options);
        return csv;
      } else {
        return csv.options.from;
      }
    },
    /*
    
      `from.array:(data, [options])`: Read from an array
      --------------------------------------------------
      
      Take an array as first argument and optionally some options 
      as a second argument. Each element of the array represents 
      a csv record. Those elements may be a string, a buffer, an
      array or an object.
    */

    array: function(data, options) {
      this.options(options);
      process.nextTick(function() {
        var i, _i, _ref;
        for (i = _i = 0, _ref = data.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
          csv.write(data[i]);
        }
        return csv.end();
      });
      return csv;
    },
    /*
      
      `from.string:(data, [options])`: Read from a string or a buffer
      ---------------------------------------------------------------
      
      Take a string as first argument and optionally an object 
      of options as a second argument. The string must be the 
      complete csv data and may contains more than one line.
    */

    string: function(data, options) {
      this.options(options);
      process.nextTick(function() {
        csv.write(data);
        return csv.end();
      });
      return csv;
    },
    /*
      
      `from.path(path, [options])`: Read from a file path
      ---------------------------------------------------
      
      Take a file path as first argument and optionally an object 
      of options as a second argument.
    */

    path: function(path, options) {
      var stream;
      this.options(options);
      stream = fs.createReadStream(path, csv.from.options());
      stream.setEncoding(csv.from.options().encoding);
      return csv.from.stream(stream, null);
    },
    /*
      
      `from.stream(readStream, [options])`: Read from a stream
      --------------------------------------------------------
      
      Take a readable stream as first argument and optionally 
      an object of options as a second argument.
    */

    stream: function(readStream, options) {
      this.options(options);
      readStream.on('data', function(data) {
        return csv.write(data.toString());
      });
      readStream.on('error', function(e) {
        return error(e);
      });
      readStream.on('end', function() {
        return csv.end();
      });
      csv.readStream = readStream;
      return csv;
    }
  };
};
