// Generated by CoffeeScript 1.3.3
/*
Module CSV - Copyright David Worms <open@adaltas.com> (BSD Licensed)

 |---------------|        |---------------|---------------|         |---------------|
 |               |        |               |               |         |               |
 |               |        |              CSV              |         |               |
 |               |        |               |               |         |               |
 |    Stream     |        |    Writer     |    Reader     |         |    Stream     |
 |    Reader     | .pipe( |     API       |     API       | ).pipe( |    Writer     | )
 |               |        |               |               |         |               |
 |               |        |               |               |         |               |
 |---------------|        |---------------|---------------|         |---------------|

 fs.createReadStream('in'.pipe(         csv()           ).pipe( fs.createWriteStream('out') )
*/

var from, options, stream, to;

stream = require('stream');

options = require('./options');

from = require('./from');

to = require('./to');

module.exports = function() {
  var CSV, csv, error, parse, state, transform, transforming, write;
  state = {
    count: 0,
    countWriten: 0,
    field: '',
    line: [],
    lastC: '',
    quoted: false,
    commented: false,
    buffer: null,
    bufferPosition: 0
  };
  transforming = false;
  CSV = function() {
    this.readable = true;
    this.writable = true;
    this.state = state;
    this.options = options();
    this.from = from(this);
    this.to = to(this);
    return this;
  };
  CSV.prototype.__proto__ = stream.prototype;
  /*
      Write data.
      Data may be string in which case it could span multiple lines. If data 
      is an object or an array, it must represent a single line.
      Preserve is for line which are not considered as CSV data.
  */

  CSV.prototype.write = function(data, preserve) {
    if (!this.writable) {
      return;
    }
    if (typeof data === 'string' && !preserve) {
      return parse(data);
    } else if (Array.isArray(data) && !transforming) {
      state.line = data;
      return transform();
    }
    if (state.count === 0 && csv.options.to.header === true) {
      write(csv.options.to.columns || csv.options.from.columns);
    }
    write(data, preserve);
    if (!transforming && !preserve) {
      return state.count++;
    }
  };
  CSV.prototype.end = function() {
    if (!this.writable) {
      return;
    }
    if (state.quoted) {
      return error(new Error('Quoted field not terminated'));
    }
    if (state.field || state.lastC === this.options.from.delimiter || state.lastC === this.options.from.quote) {
      if (csv.options.from.trim || csv.options.from.rtrim) {
        state.field = state.field.trimRight();
      }
      state.line.push(state.field);
      state.field = '';
    }
    if (state.line.length > 0) {
      transform();
    }
    if (csv.writeStream) {
      if (state.bufferPosition !== 0) {
        csv.writeStream.write(state.buffer.slice(0, state.bufferPosition));
      }
      if (this.options.to.end) {
        return csv.writeStream.end();
      } else {
        csv.emit('end', state.count);
        return csv.readable = false;
      }
    } else {
      csv.emit('end', state.count);
      return csv.readable = false;
    }
  };
  CSV.prototype.transform = function(callback) {
    this.transformer = callback;
    return this;
  };
  csv = new CSV();
  /*
      Parse a string which may hold multiple lines.
      Private state object is enriched on each character until 
      transform is called on a new line
  */

  parse = function(chars) {
    var c, escapeIsQuoted, i, isEscaped, isQuoted, isReallyEscaped, l, nextChar;
    chars = '' + chars;
    l = chars.length;
    i = 0;
    while (i < l) {
      c = chars.charAt(i);
      switch (c) {
        case csv.options.from.escape:
        case csv.options.from.quote:
          if (state.commented) {
            break;
          }
          isReallyEscaped = false;
          if (c === csv.options.from.escape) {
            nextChar = chars.charAt(i + 1);
            escapeIsQuoted = csv.options.from.escape === csv.options.from.quote;
            isEscaped = nextChar === csv.options.from.escape;
            isQuoted = nextChar === csv.options.from.quote;
            if (!(escapeIsQuoted && !state.field && !state.quoted) && (isEscaped || isQuoted)) {
              i++;
              isReallyEscaped = true;
              c = chars.charAt(i);
              state.field += c;
            }
          }
          if (!isReallyEscaped && c === csv.options.from.quote) {
            if (state.field && !state.quoted) {
              state.field += c;
              break;
            }
            if (state.quoted) {
              nextChar = chars.charAt(i + 1);
              if (nextChar && nextChar !== '\r' && nextChar !== '\n' && nextChar !== csv.options.from.delimiter) {
                return error(new Error('Invalid closing quote; found "' + nextChar + '" instead of delimiter "' + csv.options.from.delimiter + '"'));
              }
              state.quoted = false;
            } else if (state.field === '') {
              state.quoted = true;
            }
          }
          break;
        case csv.options.from.delimiter:
          if (state.commented) {
            break;
          }
          if (state.quoted) {
            state.field += c;
          } else {
            if (csv.options.from.trim || csv.options.from.rtrim) {
              state.field = state.field.trimRight();
            }
            state.line.push(state.field);
            state.field = '';
          }
          break;
        case '\n':
        case '\r':
          if (state.quoted) {
            state.field += c;
            break;
          }
          if (!csv.options.from.quoted && state.lastC === '\r') {
            break;
          }
          if (csv.options.to.lineBreaks === null) {
            csv.options.to.lineBreaks = c + (c === '\r' && chars.charAt(i + 1) === '\n' ? '\n' : '');
          }
          if (csv.options.from.trim || csv.options.from.rtrim) {
            state.field = state.field.trimRight();
          }
          state.line.push(state.field);
          state.field = '';
          transform();
          break;
        case ' ':
        case '\t':
          if (state.quoted || (!csv.options.from.trim && !csv.options.from.ltrim) || state.field) {
            state.field += c;
            break;
          }
          break;
        default:
          if (state.commented) {
            break;
          }
          state.field += c;
      }
      state.lastC = c;
      i++;
    }
  };
  /*
      Called by the `parse` function on each line. It is responsible for 
      transforming the data and finally calling `write`.
  */

  transform = function() {
    var column, columns, i, isObject, line, _i, _ref;
    line = null;
    columns = csv.options.from.columns;
    if (columns) {
      if (state.count === 0 && columns === true) {
        csv.options.from.columns = columns = state.line;
        state.line = [];
        state.lastC = '';
        return;
      }
      line = {};
      for (i = _i = 0, _ref = columns.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        column = columns[i];
        line[column] = state.line[i] || null;
      }
      state.line = line;
      line = null;
    }
    if (csv.transformer) {
      transforming = true;
      try {
        line = csv.transformer(state.line, state.count);
      } catch (e) {
        return error(e);
      }
      isObject = typeof line === 'object' && !Array.isArray(line);
      if (csv.options.to.newColumns && !csv.options.to.columns && isObject) {
        Object.keys(line).filter(function(column) {
          return columns.indexOf(column) === -1;
        }).forEach(function(column) {
          return columns.push(column);
        });
      }
      transforming = false;
    } else {
      line = state.line;
    }
    if (state.count === 0 && csv.options.to.header === true) {
      write(csv.options.to.columns || columns);
    }
    write(line);
    state.count++;
    state.line = [];
    return state.lastC = '';
  };
  /*
      Write a line to the written stream.
      Line may be an object, an array or a string
      Preserve is for line which are not considered as CSV data
  */

  write = function(line, preserve) {
    var column, columns, containsLinebreak, containsQuote, containsdelimiter, field, i, newLine, regexp, _i, _j, _line, _ref, _ref1;
    if (typeof line === 'undefined' || line === null) {
      return;
    }
    if (!preserve) {
      try {
        csv.emit('data', line, state.count);
      } catch (e) {
        return error(e);
      }
    }
    if (typeof line === 'object') {
      if (!Array.isArray(line)) {
        columns = csv.options.to.columns || csv.options.from.columns;
        _line = [];
        if (columns) {
          for (i = _i = 0, _ref = columns.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
            column = columns[i];
            _line[i] = typeof line[column] === 'undefined' || line[column] === null ? '' : line[column];
          }
        } else {
          for (column in line) {
            _line.push(line[column]);
          }
        }
        line = _line;
        _line = null;
      } else if (csv.options.to.columns) {
        line.splice(csv.options.to.columns.length);
      }
      if (Array.isArray(line)) {
        newLine = state.countWriten ? csv.options.to.lineBreaks || "\n" : '';
        for (i = _j = 0, _ref1 = line.length; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; i = 0 <= _ref1 ? ++_j : --_j) {
          field = line[i];
          if (typeof field === 'string') {

          } else if (typeof field === 'number') {
            field = '' + field;
          } else if (typeof field === 'boolean') {
            field = field ? '1' : '';
          } else if (field instanceof Date) {
            field = '' + field.getTime();
          }
          if (field) {
            containsdelimiter = field.indexOf(csv.options.to.delimiter || csv.options.from.delimiter) >= 0;
            containsQuote = field.indexOf(csv.options.to.quote || csv.options.from.quote) >= 0;
            containsLinebreak = field.indexOf("\r") >= 0 || field.indexOf("\n") >= 0;
            if (containsQuote) {
              regexp = new RegExp(csv.options.to.quote || csv.options.from.quote, 'g');
              field = field.replace(regexp, (csv.options.to.escape || csv.options.from.escape) + (csv.options.to.quote || csv.options.from.quote));
            }
            if (containsQuote || containsdelimiter || containsLinebreak || csv.options.to.quoted) {
              field = (csv.options.to.quote || csv.options.from.quote) + field + (csv.options.to.quote || csv.options.from.quote);
            }
            newLine += field;
          }
          if (i !== line.length - 1) {
            newLine += csv.options.to.delimiter || csv.options.from.delimiter;
          }
        }
        line = newLine;
      }
    } else if (typeof line === 'number') {
      line = '' + line;
    }
    if (state.buffer) {
      if (state.bufferPosition + Buffer.byteLength(line, csv.options.to.encoding) > csv.options.from.bufferSize) {
        csv.writeStream.write(state.buffer.slice(0, state.bufferPosition));
        state.buffer = new Buffer(csv.options.from.bufferSize);
        state.bufferPosition = 0;
      }
      state.bufferPosition += state.buffer.write(line, state.bufferPosition, csv.options.to.encoding);
    }
    if (!preserve) {
      state.countWriten++;
    }
    return true;
  };
  error = function(e) {
    csv.readable = false;
    csv.writable = false;
    csv.emit('error', e);
    if (csv.readStream) {
      csv.readStream.destroy();
    }
    return e;
  };
  return csv;
};
