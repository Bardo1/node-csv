// Generated by CoffeeScript 1.3.3
/*
Module CSV - Copyright David Worms <open@adaltas.com> (BSD Licensed)

|-----------|      |---------|---------|       |---------|
|           |      |         |         |       |         |
|           |      |        CSV        |       |         |
|           |      |         |         |       |         |
|  Stream   |      |  Writer |  Reader |       |  Stream |
|  Reader   |.pipe(|   API   |   API   |).pipe(|  Writer |)
|           |      |         |         |       |         |
|           |      |         |         |       |         |
|-----------|      |---------|---------|       |---------|

fs.createReadStream('./in'.pipe(csv()).pipe( fs.createWriteStream('./out'))
*/

var Parser, Stringifier, from, options, state, stream, to;

stream = require('stream');

state = require('./state');

options = require('./options');

from = require('./from');

to = require('./to');

Stringifier = require('./Stringifier');

Parser = require('./Parser');

module.exports = function() {
  var CSV, csv, error, transform, write;
  CSV = function() {
    this.readable = true;
    this.writable = true;
    this.state = state();
    this.options = options();
    this.from = from(this);
    this.to = to(this);
    this.parser = Parser(this);
    this.parser.on('row', function(row) {
      return transform(row);
    });
    this.parser.on('end', (function() {
      this.emit('end', this.state.count);
      return this.readable = false;
    }).bind(this));
    this.parser.on('error', function(e) {
      return error(e);
    });
    this.stringifier = new Stringifier(this);
    return this;
  };
  CSV.prototype.__proto__ = stream.prototype;
  /*
  
    `write(data, [preserve])`: Write data
    -------------------------------------
  
    Implementation of the StreamWriter API with a larger signature. Data
    may be a string, a buffer, an array or an object.
  
    If data is a string or a buffer, it could span multiple lines. If data 
    is an object or an array, it must represent a single line.
    Preserve is for line which are not considered as CSV data.
  */

  CSV.prototype.write = function(data, preserve) {
    if (!this.writable) {
      return;
    }
    if (typeof data === 'string' && !preserve) {
      return this.parser.parse(data);
    }
    if (Array.isArray(data) && !this.state.transforming) {
      return transform(data);
    }
    if (this.state.count === 0 && this.options.to.header === true) {
      write(this.options.to.columns || this.options.from.columns);
    }
    write(data, preserve);
    if (!this.state.transforming && !preserve) {
      return this.state.count++;
    }
  };
  /*
  
    `end()`: Terminate the parsing
    -------------------------------
  
    Call this method when no more csv data is to be parsed. It 
    implement the StreamWriter API by setting the `writable` 
    property to "false" and emitting the `end` event.
  */

  CSV.prototype.end = function() {
    if (!this.writable) {
      return;
    }
    return this.parser.end();
  };
  /*
  
    `transform(callback)`: Register the transformer callback
    --------------------------------------------------------
  
    User provided function call on each line to filter, enrich or modify 
    the dataset. The callback is called asynchronously.
  */

  CSV.prototype.transform = function(callback) {
    this.transformer = callback;
    return this;
  };
  csv = new CSV();
  /*
    Called by the `parse` function on each line. It is responsible for 
    transforming the data and finally calling `write`.
  */

  transform = function(line) {
    var column, columns, i, isObject, lineAsObject, _i, _len;
    columns = csv.options.from.columns;
    if (columns) {
      if (csv.state.count === 0 && columns === true) {
        csv.options.from.columns = columns = line;
        return;
      }
      lineAsObject = {};
      for (i = _i = 0, _len = columns.length; _i < _len; i = ++_i) {
        column = columns[i];
        lineAsObject[column] = line[i] || null;
      }
      line = lineAsObject;
    }
    if (csv.transformer) {
      csv.state.transforming = true;
      try {
        line = csv.transformer(line, csv.state.count);
      } catch (e) {
        return error(e);
      }
      isObject = typeof line === 'object' && !Array.isArray(line);
      if (csv.options.to.newColumns && !csv.options.to.columns && isObject) {
        Object.keys(line).filter(function(column) {
          return columns.indexOf(column) === -1;
        }).forEach(function(column) {
          return columns.push(column);
        });
      }
      csv.state.transforming = false;
    }
    if (csv.state.count === 0 && csv.options.to.header === true) {
      write(csv.options.to.columns || columns);
    }
    write(line);
    return csv.state.count++;
  };
  /*
    Write a line to the written stream.
    Line may be an object, an array or a string
    Preserve is for line which are not considered as CSV data
  */

  write = function(line, preserve) {
    if (typeof line === 'undefined' || line === null) {
      return;
    }
    if (!preserve) {
      try {
        csv.emit('record', line, csv.state.count);
      } catch (e) {
        return error(e);
      }
      line = csv.stringifier.stringify(line);
    }
    csv.emit('data', line);
    if (!preserve) {
      csv.state.countWriten++;
    }
    return true;
  };
  error = function(e) {
    csv.readable = false;
    csv.writable = false;
    csv.emit('error', e);
    if (csv.readStream) {
      csv.readStream.destroy();
    }
    return e;
  };
  return csv;
};
