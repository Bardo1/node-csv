// Generated by CoffeeScript 1.3.3
/*
Module CSV - Copyright David Worms <open@adaltas.com> (BSD Licensed)

 |---------------|        |---------------|---------------|         |---------------|
 |               |        |               |               |         |               |
 |               |        |              CSV              |         |               |
 |               |        |               |               |         |               |
 |    Stream     |        |    Writer     |    Reader     |         |    Stream     |
 |    Reader     | .pipe( |     API       |     API       | ).pipe( |    Writer     | )
 |               |        |               |               |         |               |
 |               |        |               |               |         |               |
 |---------------|        |---------------|---------------|         |---------------|

 fs.createReadStream('in'.pipe(         csv()           ).pipe( fs.createWriteStream('out') )
*/

var from, options, state, stream, stringify, to;

stream = require('stream');

state = require('./state');

options = require('./options');

from = require('./from');

to = require('./to');

stringify = require('./stringify');

module.exports = function() {
  var CSV, csv, error, parse, transform, write;
  CSV = function() {
    this.readable = true;
    this.writable = true;
    this.state = state();
    this.options = options();
    this.from = from(this);
    this.to = to(this);
    return this;
  };
  CSV.prototype.__proto__ = stream.prototype;
  /*
  
      `write(data, [preserve])`: Write data
      -------------------------------------
  
      Implementation of the StreamWriter API with a larger signature. Data
      may be a string, a buffer, an array or an object.
  
      If data is a string or a buffer, it could span multiple lines. If data 
      is an object or an array, it must represent a single line.
      Preserve is for line which are not considered as CSV data.
  */

  CSV.prototype.write = function(data, preserve) {
    if (!this.writable) {
      return;
    }
    if (typeof data === 'string' && !preserve) {
      return parse(data);
    } else if (Array.isArray(data) && !this.state.transforming) {
      this.state.line = data;
      return transform();
    }
    if (this.state.count === 0 && this.options.to.header === true) {
      write(this.options.to.columns || this.options.from.columns);
    }
    write(data, preserve);
    if (!this.state.transforming && !preserve) {
      return this.state.count++;
    }
  };
  /*
  
      `end()`: Terminate the parsing
      -------------------------------
  
      Call this method when no more csv data is to be parsed. It 
      implement the StreamWriter API by setting the `writable` 
      property to "false" and emitting the `end` event.
  */

  CSV.prototype.end = function() {
    if (!this.writable) {
      return;
    }
    if (this.state.quoted) {
      return error(new Error('Quoted field not terminated'));
    }
    if (this.state.field || this.state.lastC === this.options.from.delimiter || this.state.lastC === this.options.from.quote) {
      if (this.options.from.trim || this.options.from.rtrim) {
        this.state.field = this.state.field.trimRight();
      }
      this.state.line.push(this.state.field);
      this.state.field = '';
    }
    if (this.state.line.length > 0) {
      transform();
    }
    if (this.writeStream) {
      if (this.state.bufferPosition !== 0) {
        this.writeStream.write(this.state.buffer.slice(0, this.state.bufferPosition));
      }
      if (this.options.to.end) {
        return this.writeStream.end();
      } else {
        this.emit('end', this.state.count);
        return this.readable = false;
      }
    } else {
      this.emit('end', this.state.count);
      return this.readable = false;
    }
  };
  /*
  
      `transform(callback)`: Register the transformer callback
      --------------------------------------------------------
  
      User provided function call on each line to filter, enrich or modify 
      the dataset. The callback is called asynchronously.
  */

  CSV.prototype.transform = function(callback) {
    this.transformer = callback;
    return this;
  };
  csv = new CSV();
  /*
      Parse a string which may hold multiple lines.
      Private state object is enriched on each character until 
      transform is called on a new line
  */

  parse = function(chars) {
    var c, escapeIsQuoted, i, isEscaped, isQuoted, isReallyEscaped, l, nextChar;
    chars = '' + chars;
    l = chars.length;
    i = 0;
    while (i < l) {
      c = chars.charAt(i);
      switch (c) {
        case csv.options.from.escape:
        case csv.options.from.quote:
          if (csv.state.commented) {
            break;
          }
          isReallyEscaped = false;
          if (c === csv.options.from.escape) {
            nextChar = chars.charAt(i + 1);
            escapeIsQuoted = csv.options.from.escape === csv.options.from.quote;
            isEscaped = nextChar === csv.options.from.escape;
            isQuoted = nextChar === csv.options.from.quote;
            if (!(escapeIsQuoted && !csv.state.field && !csv.state.quoted) && (isEscaped || isQuoted)) {
              i++;
              isReallyEscaped = true;
              c = chars.charAt(i);
              csv.state.field += c;
            }
          }
          if (!isReallyEscaped && c === csv.options.from.quote) {
            if (csv.state.field && !csv.state.quoted) {
              csv.state.field += c;
              break;
            }
            if (csv.state.quoted) {
              nextChar = chars.charAt(i + 1);
              if (nextChar && nextChar !== '\r' && nextChar !== '\n' && nextChar !== csv.options.from.delimiter) {
                return error(new Error('Invalid closing quote; found "' + nextChar + '" instead of delimiter "' + csv.options.from.delimiter + '"'));
              }
              csv.state.quoted = false;
            } else if (csv.state.field === '') {
              csv.state.quoted = true;
            }
          }
          break;
        case csv.options.from.delimiter:
          if (csv.state.commented) {
            break;
          }
          if (csv.state.quoted) {
            csv.state.field += c;
          } else {
            if (csv.options.from.trim || csv.options.from.rtrim) {
              csv.state.field = csv.state.field.trimRight();
            }
            csv.state.line.push(csv.state.field);
            csv.state.field = '';
          }
          break;
        case '\n':
        case '\r':
          if (csv.state.quoted) {
            csv.state.field += c;
            break;
          }
          if (!csv.options.from.quoted && csv.state.lastC === '\r') {
            break;
          }
          if (csv.options.to.lineBreaks === null) {
            csv.options.to.lineBreaks = c + (c === '\r' && chars.charAt(i + 1) === '\n' ? '\n' : '');
          }
          if (csv.options.from.trim || csv.options.from.rtrim) {
            csv.state.field = csv.state.field.trimRight();
          }
          csv.state.line.push(csv.state.field);
          csv.state.field = '';
          transform();
          break;
        case ' ':
        case '\t':
          if (csv.state.quoted || (!csv.options.from.trim && !csv.options.from.ltrim) || csv.state.field) {
            csv.state.field += c;
            break;
          }
          break;
        default:
          if (csv.state.commented) {
            break;
          }
          csv.state.field += c;
      }
      csv.state.lastC = c;
      i++;
    }
  };
  /*
      Called by the `parse` function on each line. It is responsible for 
      transforming the data and finally calling `write`.
  */

  transform = function() {
    var column, columns, i, isObject, line, _i, _ref;
    line = null;
    columns = csv.options.from.columns;
    if (columns) {
      if (csv.state.count === 0 && columns === true) {
        csv.options.from.columns = columns = csv.state.line;
        csv.state.line = [];
        csv.state.lastC = '';
        return;
      }
      line = {};
      for (i = _i = 0, _ref = columns.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        column = columns[i];
        line[column] = csv.state.line[i] || null;
      }
      csv.state.line = line;
      line = null;
    }
    if (csv.transformer) {
      csv.state.transforming = true;
      try {
        line = csv.transformer(csv.state.line, csv.state.count);
      } catch (e) {
        return error(e);
      }
      isObject = typeof line === 'object' && !Array.isArray(line);
      if (csv.options.to.newColumns && !csv.options.to.columns && isObject) {
        Object.keys(line).filter(function(column) {
          return columns.indexOf(column) === -1;
        }).forEach(function(column) {
          return columns.push(column);
        });
      }
      csv.state.transforming = false;
    } else {
      line = csv.state.line;
    }
    if (csv.state.count === 0 && csv.options.to.header === true) {
      write(csv.options.to.columns || columns);
    }
    write(line);
    csv.state.count++;
    csv.state.line = [];
    return csv.state.lastC = '';
  };
  /*
      Write a line to the written stream.
      Line may be an object, an array or a string
      Preserve is for line which are not considered as CSV data
  */

  write = function(line, preserve) {
    if (typeof line === 'undefined' || line === null) {
      return;
    }
    if (!preserve) {
      try {
        csv.emit('record', line, csv.state.count);
      } catch (e) {
        return error(e);
      }
    }
    line = stringify(line, csv);
    if (csv.state.buffer) {
      if (csv.state.bufferPosition + Buffer.byteLength(line, csv.options.to.encoding) > csv.options.from.bufferSize) {
        csv.writeStream.write(csv.state.buffer.slice(0, csv.state.bufferPosition));
        csv.state.buffer = new Buffer(csv.options.from.bufferSize);
        csv.state.bufferPosition = 0;
      }
      csv.state.bufferPosition += csv.state.buffer.write(line, csv.state.bufferPosition, csv.options.to.encoding);
    }
    if (!preserve) {
      csv.state.countWriten++;
    }
    return true;
  };
  error = function(e) {
    csv.readable = false;
    csv.writable = false;
    csv.emit('error', e);
    if (csv.readStream) {
      csv.readStream.destroy();
    }
    return e;
  };
  return csv;
};
