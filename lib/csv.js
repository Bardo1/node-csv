// Generated by CoffeeScript 1.3.3
/*
Module CSV - Copyright David Worms <open@adaltas.com> (BSD Licensed)

|-----------|      |---------|---------|       |---------|
|           |      |         |         |       |         |
|           |      |        CSV        |       |         |
|           |      |         |         |       |         |
|  Stream   |      |  Writer |  Reader |       |  Stream |
|  Reader   |.pipe(|   API   |   API   |).pipe(|  Writer |)
|           |      |         |         |       |         |
|           |      |         |         |       |         |
|-----------|      |---------|---------|       |---------|

fs.createReadStream('./in'.pipe(csv()).pipe( fs.createWriteStream('./out'))
*/

var Parser, from, options, state, stream, stringify, to;

stream = require('stream');

state = require('./state');

options = require('./options');

from = require('./from');

to = require('./to');

stringify = require('./stringify');

Parser = require('./Parser');

module.exports = function() {
  var CSV, csv, error, transform, write;
  CSV = function() {
    this.readable = true;
    this.writable = true;
    this.state = state();
    this.options = options();
    this.from = from(this);
    this.to = to(this);
    this.parser = Parser(this);
    this.parser.on('row', function(row) {
      return transform();
    });
    this.parser.on('error', function(e) {
      return error(e);
    });
    return this;
  };
  CSV.prototype.__proto__ = stream.prototype;
  /*
  
    `write(data, [preserve])`: Write data
    -------------------------------------
  
    Implementation of the StreamWriter API with a larger signature. Data
    may be a string, a buffer, an array or an object.
  
    If data is a string or a buffer, it could span multiple lines. If data 
    is an object or an array, it must represent a single line.
    Preserve is for line which are not considered as CSV data.
  */

  CSV.prototype.write = function(data, preserve) {
    if (!this.writable) {
      return;
    }
    if (typeof data === 'string' && !preserve) {
      return this.parser.parse(data);
    }
    if (Array.isArray(data) && !this.state.transforming) {
      this.state.line = data;
      return transform();
    }
    if (this.state.count === 0 && this.options.to.header === true) {
      write(this.options.to.columns || this.options.from.columns);
    }
    write(data, preserve);
    if (!this.state.transforming && !preserve) {
      return this.state.count++;
    }
  };
  /*
  
    `end()`: Terminate the parsing
    -------------------------------
  
    Call this method when no more csv data is to be parsed. It 
    implement the StreamWriter API by setting the `writable` 
    property to "false" and emitting the `end` event.
  */

  CSV.prototype.end = function() {
    if (!this.writable) {
      return;
    }
    this.parser.end();
    return this.parser.on('end', (function() {
      console.log('end');
      if (this.writeStream) {
        if (this.state.bufferPosition !== 0) {
          this.writeStream.write(this.state.buffer.slice(0, this.state.bufferPosition));
        }
        if (this.options.to.end) {
          return this.writeStream.end();
        } else {
          this.emit('end', this.state.count);
          return this.readable = false;
        }
      } else {
        this.emit('end', this.state.count);
        return this.readable = false;
      }
    }).bind(this));
  };
  /*
  
    `transform(callback)`: Register the transformer callback
    --------------------------------------------------------
  
    User provided function call on each line to filter, enrich or modify 
    the dataset. The callback is called asynchronously.
  */

  CSV.prototype.transform = function(callback) {
    this.transformer = callback;
    return this;
  };
  csv = new CSV();
  /*
    Called by the `parse` function on each line. It is responsible for 
    transforming the data and finally calling `write`.
  */

  transform = function() {
    var column, columns, i, isObject, line, _i, _ref;
    line = null;
    columns = csv.options.from.columns;
    if (columns) {
      if (csv.state.count === 0 && columns === true) {
        csv.options.from.columns = columns = csv.state.line;
        csv.state.line = [];
        csv.state.lastC = '';
        return;
      }
      line = {};
      for (i = _i = 0, _ref = columns.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        column = columns[i];
        line[column] = csv.state.line[i] || null;
      }
      csv.state.line = line;
      line = null;
    }
    if (csv.transformer) {
      csv.state.transforming = true;
      try {
        line = csv.transformer(csv.state.line, csv.state.count);
      } catch (e) {
        return error(e);
      }
      isObject = typeof line === 'object' && !Array.isArray(line);
      if (csv.options.to.newColumns && !csv.options.to.columns && isObject) {
        Object.keys(line).filter(function(column) {
          return columns.indexOf(column) === -1;
        }).forEach(function(column) {
          return columns.push(column);
        });
      }
      csv.state.transforming = false;
    } else {
      line = csv.state.line;
    }
    if (csv.state.count === 0 && csv.options.to.header === true) {
      write(csv.options.to.columns || columns);
    }
    write(line);
    csv.state.count++;
    csv.state.line = [];
    return csv.state.lastC = '';
  };
  /*
    Write a line to the written stream.
    Line may be an object, an array or a string
    Preserve is for line which are not considered as CSV data
  */

  write = function(line, preserve) {
    if (typeof line === 'undefined' || line === null) {
      return;
    }
    if (!preserve) {
      try {
        csv.emit('record', line, csv.state.count);
      } catch (e) {
        return error(e);
      }
    }
    line = stringify(line, csv);
    if (csv.state.buffer) {
      if (csv.state.bufferPosition + Buffer.byteLength(line, csv.options.to.encoding) > csv.options.from.bufferSize) {
        csv.writeStream.write(csv.state.buffer.slice(0, csv.state.bufferPosition));
        csv.state.buffer = new Buffer(csv.options.from.bufferSize);
        csv.state.bufferPosition = 0;
      }
      csv.state.bufferPosition += csv.state.buffer.write(line, csv.state.bufferPosition, csv.options.to.encoding);
    }
    if (!preserve) {
      csv.state.countWriten++;
    }
    return true;
  };
  error = function(e) {
    csv.readable = false;
    csv.writable = false;
    csv.emit('error', e);
    if (csv.readStream) {
      csv.readStream.destroy();
    }
    return e;
  };
  return csv;
};
